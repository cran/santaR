<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Arnaud Wolfer" />

<meta name="date" content="2019-10-03" />

<title>santaR Theoretical Background</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">santaR Theoretical Background</h1>
<h4 class="author">Arnaud Wolfer</h4>
<h4 class="date">2019-10-03</h4>



<p><code>santaR</code> is a Functional Data Analysis (<em>FDA</em>)
approach where each individual’s observations are condensed to a
continuous smooth function of time, which is then employed as a new
analytical unit in subsequent data analysis.</p>
<p><code>santaR</code> is designed to be automatically applicable to a
<em>high number of variables</em>, while simultaneously accounting
for:</p>
<ul>
<li><em>biological variability</em></li>
<li><em>measurement error</em></li>
<li><em>missing observations</em></li>
<li><em>asynchronous sampling</em></li>
<li><em>nonlinearity</em></li>
<li><em>low number of time points</em> (e.g. 4-10)</li>
</ul>
<p>This vignette focusses on the theoretical background underlying
<code>santaR</code> and will detail:</p>
<ul>
<li>Concept of Functional Data Analysis</li>
<li>Main hypothesis</li>
<li>Signal extraction using splines</li>
<li>Group mean curve fitting</li>
<li>Intra-class variability (confidence bands on the Group mean
curves)</li>
<li>Detection of significantly altered time-trajectories</li>
</ul>
<div id="concept-of-functional-data-analysis" class="section level2">
<h2>Concept of Functional Data Analysis</h2>
<p>Traditional times-series methodologies consider each measurement (or
observation) - for example a metabolic response value at a defined
time-point - as the basic representative unit. In this context, a time
trajectory is composed of a set of discrete observations taken at
subsequent times. Functional data analysis<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> <a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> is a framework
proposed by Ramsay and Silverman which models continuously each measured
values as variable evolves (e.g. time). Contrary to traditional
time-series approaches, FDA consider a subject’s entire time-trajectory
as a single data point. This continuous representation of the variable
through time is then employed for further data analysis.</p>
<p>More precisely, FDA assumes that a variable’s time trajectory is the
result of a smooth underlying function of time which must be estimated.
Therefore, the analysis’ first step is to convert a subject’s successive
observations to the underlying function <span class="math inline">\(F(t)\)</span> that can be evaluated at any desired
time values</p>
<p>Two main challenges prescribe the exact characterisation of the true
underlying function of time <span class="math inline">\(F(t)\)</span>.
First, the limited number of discrete observations constrains to a
finite time interval and does not cover all possible values, while the
true underlying smooth process is infinitely defined. Secondly,
intrinsic limitations and variabilities of the analytical platforms mean
that the discrete observations are not capturing the true underlying
function values, but a succession of noisy realisations.</p>
<p>A metabolite’s concentration over the duration of the experiment is
the real quantity of interest. As the true smooth process <span class="math inline">\(F(t)\)</span> cannot be evaluated, due to the
collection and analytical process only providing noisy snapshots of its
value, an approximation of the underlying metabolite concentration <span class="math inline">\(f(t)\)</span> must be employed. This approximation
can be computed by smoothing the multiple single measurements
available.</p>
<p>The approximation of the underlying function of time, of a single
variable observed on a single subject, is generated by smoothing <span class="math inline">\(y_i\)</span> observations taken at the time <span class="math inline">\(t_i\)</span>, such as:</p>
<p><span class="math display">\[y_{i}=f(t_{i})+\epsilon_{i}\]</span></p>
<p>Where <span class="math inline">\(f(t)\)</span> is the smoothed
function that can be evaluated at any desired time <span class="math inline">\(t\)</span> within the defined time domain, and
<span class="math inline">\(\epsilon_i\)</span> is an error term
allowing for measurement errors. By extension, if <span class="math inline">\(f(t)\)</span> is defined as representing the true
variable level across a population, <span class="math inline">\(\epsilon\)</span> can allow for both individual
specific deviation and measurement error.</p>
<p>In order to parametrise and computationally manipulate the smooth
approximation, the representation is projected onto a finite basis,
which expresses the infinitesimally dimensional <span class="math inline">\(f(t)\)</span> as a linear combination of a set of
basis functions. A wide range of basis functions (e.g. polynomials,
splines, wavelets, Fourier basis) are available, even if the most
commonly used are Fourier basis for periodic data and splines for
aperiodic trajectories<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<p>Following smoothing, a time-trajectory is expressed as a linear
combination of a set of basis functions, for which values can be
computer at any desired time without reconsidering the discrete
observations. It is assumed that, if a satisfactory fit of the original
data is obtained, both the new smooth approximation and the preceding
noisy realisations should provide a similar representation of the
underlying process<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> <a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<p>In practice, by assuming and parametrising <em>(explicitely or
implicitely)</em> the smoothness of the function and leveraging multiple
measurements in time as well as multiple individual trajectories, the
smoothed representation can implicitly handle noisy metabolic responses.
Additionally, as functional representations do not rely on the input
data after their generation, smoothing approaches can handle irregular
sampling and missing observations, translating to trajectories that can
be compared without requiring missing values imputation. As such, the
FDA framework and the smoothness assumption provide the necessary tools
for the time-dependent analysis of short and noisy metabolic
time-trajectories.</p>
</div>
<div id="main-hypothesis" class="section level2">
<h2>Main hypothesis</h2>
<p>The working hypothesis is that analyte values are representative of
the underlying biological mechanism responsible for the observed
phenotype and evolve smoothly through time. The resulting measurements
are noisy realisations of these underlying smooth functions of time.</p>
<p>Based on previous work performed in Functional Data Analysis, short
time evolutions can be analysed by estimating each individual trajectory
as a smooth spline or curve. These smooth curves collapse the point by
point information into a new observational unit that enables the
calculation of a group mean curve or individual curves, each
representative of the true underlying function of time.</p>
<p>Further data analysis then results in the estimation of the
intra-class variability and the identification of time trajectories
significantly altered between classes.</p>
</div>
<div id="signal-extraction-using-splines" class="section level2">
<h2>Signal extraction using splines</h2>
<p>Fitting splines to time trajectories is equivalent to a denoising or
signal extraction problem: balancing the fitting of raw data versus the
smoothing of the biological variability and measurement errors. Splines
are piecewise polynomials with boundary continuity and smoothness
constraints, which require a minimum of assumptions about the underlying
form of the data<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> <a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> <a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>. The complexity of the fit is controlled by
a single smoothing parameter <span class="math inline">\(\lambda\)</span>.</p>
<p>The data <span class="math inline">\(y_{ij}\)</span> of individual
<span class="math inline">\(i\)</span>, <span class="math inline">\(i=1,.,n_k\)</span>, observed at time points <span class="math inline">\(t_{ij}\)</span>, <span class="math inline">\(j=1,.,m_i\)</span>, in a group of <span class="math inline">\(n_k\)</span> individuals, is modelled by a
smoothing spline <span class="math inline">\(f_i(t_{ij})\)</span> of
continuous first and second derivatives that minimizes the penalized
residual sum of squares (<em>PRSS</em>) (Eq. 1):</p>
<p><span class="math display">\[PRSS(f_{i},\lambda)=\sum_{j=1}^{m_{i}}
\{y_{ij} - f_i(t_{ij})\}^2 + \lambda
\int_{t_{min}}^{t_{max}}\{\ddot{f_i(t)}\}^2~dt\]</span> (Eq. 1)</p>
<p>The first term of Eq. 1 is the squared error of employing the curve
<span class="math inline">\(f_i(t)\)</span> to predict <span class="math inline">\(y_{ij}\)</span>, measuring the closeness of the
function to the data. The second term penalises the curvature of the
function while <span class="math inline">\(\lambda\)</span> controls the
trade-off between both terms. The smoothing parameter <span class="math inline">\(\lambda\)</span> is shared among all individuals.
The monotonic relationship between the smoothing parameter <span class="math inline">\(\lambda\)</span> and the desired equivalent number
of degrees of freedom (<em>df</em>) of the corresponding fit (Eq. 2),
allows us to control the closeness of curve fitting by varying
<em>df</em><a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>.</p>
<p><span class="math display">\[df_{\lambda}=trace(S_{\lambda})\]</span>
(Eq. 2)</p>
<p>where <span class="math inline">\(S_{\lambda}\)</span> is the
smoother matrix (roughness matrix, or hat matrix) which transforms the
observed data vector to the vector of fitted values (for more
information see Eubank<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>, and Buja <em>et al</em>.<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>).</p>
<p>The <em>df</em> parameter controls how closely the spline fits the
input data. For example, when <em>df</em> is minimal (<em>df</em>=2),
the smoothing is maximised and the original data points fitted with a
straight line. On the other hand, when <em>df</em> approaches the number
of time-points, every data point is fitted without smoothing, which can
result in an over-fit of the raw measurements.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gridExtra)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(grid)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample a gaussian distribution, add noise to it</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>x       <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">4</span>, <span class="sc">-</span><span class="dv">3</span>, <span class="sc">-</span><span class="dv">2</span>, <span class="sc">-</span><span class="fl">1.5</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="sc">-</span><span class="fl">0.5</span>, <span class="dv">0</span>, <span class="fl">0.5</span>,  <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>y       <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(x, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="dv">1</span>, <span class="at">log=</span><span class="cn">FALSE</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>y_noise <span class="ot">&lt;-</span> <span class="fu">jitter</span>(y, <span class="dv">90</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit different smoothing splines, project on a grid for plotting</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>time     <span class="ot">=</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">4</span>, <span class="dv">4</span>, <span class="fl">0.01</span> )</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>tmp_fit0 <span class="ot">=</span> <span class="fu">smooth.spline</span>(x, y, <span class="at">df=</span><span class="dv">13</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>tmp_fit1 <span class="ot">=</span> <span class="fu">smooth.spline</span>(x, y_noise, <span class="at">df=</span><span class="dv">2</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>tmp_fit2 <span class="ot">=</span> <span class="fu">smooth.spline</span>(x, y_noise, <span class="at">df=</span><span class="dv">5</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>tmp_fit3 <span class="ot">=</span> <span class="fu">smooth.spline</span>(x, y_noise, <span class="at">df=</span><span class="dv">13</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>pred0    <span class="ot">=</span> <span class="fu">predict</span>( <span class="at">object=</span>tmp_fit0, <span class="at">x=</span>time )</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>pred1    <span class="ot">=</span> <span class="fu">predict</span>( <span class="at">object=</span>tmp_fit1, <span class="at">x=</span>time )</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>pred2    <span class="ot">=</span> <span class="fu">predict</span>( <span class="at">object=</span>tmp_fit2, <span class="at">x=</span>time )</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>pred3    <span class="ot">=</span> <span class="fu">predict</span>( <span class="at">object=</span>tmp_fit3, <span class="at">x=</span>time )</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>tmpPred0 <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">x=</span>pred0<span class="sc">$</span>x, <span class="at">y=</span>pred0<span class="sc">$</span>y)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>tmpPred1 <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">x=</span>pred1<span class="sc">$</span>x, <span class="at">y=</span>pred1<span class="sc">$</span>y)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>tmpPred2 <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">x=</span>pred2<span class="sc">$</span>x, <span class="at">y=</span>pred2<span class="sc">$</span>y)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>tmpPred3 <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">x=</span>pred3<span class="sc">$</span>x, <span class="at">y=</span>pred3<span class="sc">$</span>y)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>tmpRaw   <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">x=</span>x,  <span class="at">y=</span>y)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>tmpNoisy <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">x=</span>x,  <span class="at">y=</span>y_noise)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot original data and spline representations</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>p0 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="cn">NULL</span>, <span class="fu">aes</span>(x), <span class="at">environment =</span> <span class="fu">environment</span>()) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">xlim</span>(<span class="sc">-</span><span class="dv">4</span>,<span class="dv">4</span>) <span class="sc">+</span> <span class="fu">ylim</span>(<span class="sc">-</span><span class="fl">0.1</span>,<span class="fl">0.5</span>) <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">axis.title.y =</span> <span class="fu">element_blank</span>(), <span class="at">axis.ticks =</span> <span class="fu">element_blank</span>(), <span class="at">axis.text.x =</span> <span class="fu">element_blank</span>(), <span class="at">axis.text.y =</span> <span class="fu">element_blank</span>(), <span class="at">plot.margin=</span><span class="fu">unit</span>(<span class="fu">c</span>(<span class="fl">0.5</span>,<span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="dv">0</span>), <span class="st">&quot;cm&quot;</span>))</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>p0 <span class="ot">&lt;-</span> p0 <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data=</span>tmpRaw, <span class="fu">aes</span>(<span class="at">x=</span>x, <span class="at">y=</span>y), <span class="at">size=</span><span class="fl">1.5</span> )</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>p0 <span class="ot">&lt;-</span> p0 <span class="sc">+</span> <span class="fu">geom_line</span>( <span class="at">data=</span>tmpPred0, <span class="fu">aes</span>(<span class="at">x=</span>x, <span class="at">y=</span>y), <span class="at">linetype=</span><span class="dv">1</span>, <span class="at">color=</span><span class="st">&#39;springgreen3&#39;</span> )</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>p0 <span class="ot">&lt;-</span> p0 <span class="sc">+</span> <span class="fu">xlab</span>(<span class="fu">expression</span>(<span class="fu">atop</span>(<span class="st">&#39;True underlying&#39;</span>, <span class="fu">paste</span>(<span class="st">&#39;function of time&#39;</span>))))</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="cn">NULL</span>, <span class="fu">aes</span>(x), <span class="at">environment =</span> <span class="fu">environment</span>()) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">xlim</span>(<span class="sc">-</span><span class="dv">4</span>,<span class="dv">4</span>) <span class="sc">+</span> <span class="fu">ylim</span>(<span class="sc">-</span><span class="fl">0.1</span>,<span class="fl">0.5</span>) <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">axis.title.y =</span> <span class="fu">element_blank</span>(), <span class="at">axis.ticks =</span> <span class="fu">element_blank</span>(), <span class="at">axis.text.x =</span> <span class="fu">element_blank</span>(), <span class="at">axis.text.y =</span> <span class="fu">element_blank</span>(), <span class="at">plot.margin=</span><span class="fu">unit</span>(<span class="fu">c</span>(<span class="fl">0.5</span>,<span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="sc">-</span><span class="fl">0.25</span>), <span class="st">&quot;cm&quot;</span>))</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> p1 <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data=</span>tmpNoisy, <span class="fu">aes</span>(<span class="at">x=</span>x, <span class="at">y=</span>y), <span class="at">size=</span><span class="fl">1.5</span> )</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> p1 <span class="sc">+</span> <span class="fu">geom_line</span>( <span class="at">data=</span>tmpPred1, <span class="fu">aes</span>(<span class="at">x=</span>x, <span class="at">y=</span>y), <span class="at">linetype=</span><span class="dv">1</span>, <span class="at">color=</span><span class="st">&#39;blue&#39;</span> )</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> p1 <span class="sc">+</span> <span class="fu">xlab</span>(<span class="fu">expression</span>(<span class="fu">atop</span>(lambda<span class="sc">*</span><span class="st">&#39; -&gt; &#39;</span><span class="sc">*</span>infinity, <span class="fu">paste</span>(<span class="st">&#39;DF = 2&#39;</span>))))</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="cn">NULL</span>, <span class="fu">aes</span>(x), <span class="at">environment =</span> <span class="fu">environment</span>()) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">xlim</span>(<span class="sc">-</span><span class="dv">4</span>,<span class="dv">4</span>) <span class="sc">+</span> <span class="fu">ylim</span>(<span class="sc">-</span><span class="fl">0.1</span>,<span class="fl">0.5</span>) <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">axis.title.y =</span> <span class="fu">element_blank</span>(), <span class="at">axis.ticks =</span> <span class="fu">element_blank</span>(), <span class="at">axis.text.x =</span> <span class="fu">element_blank</span>(), <span class="at">axis.text.y =</span> <span class="fu">element_blank</span>(), <span class="at">plot.margin=</span><span class="fu">unit</span>(<span class="fu">c</span>(<span class="fl">0.5</span>,<span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="sc">-</span><span class="fl">0.25</span>), <span class="st">&quot;cm&quot;</span>))</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> p2 <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data=</span>tmpNoisy, <span class="fu">aes</span>(<span class="at">x=</span>x, <span class="at">y=</span>y), <span class="at">size=</span><span class="fl">1.5</span> )</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> p2 <span class="sc">+</span> <span class="fu">geom_line</span>( <span class="at">data=</span>tmpPred2, <span class="fu">aes</span>(<span class="at">x=</span>x, <span class="at">y=</span>y), <span class="at">linetype=</span><span class="dv">1</span>, <span class="at">color=</span><span class="st">&#39;blue&#39;</span> )</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> p2 <span class="sc">+</span> <span class="fu">xlab</span>(<span class="fu">expression</span>(<span class="fu">atop</span>(<span class="st">&#39;Optimal &#39;</span><span class="sc">*</span>lambda, <span class="fu">paste</span>(<span class="st">&#39;Optimal DF&#39;</span>, <span class="at">sep=</span><span class="st">&#39;&#39;</span>))))</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="cn">NULL</span>, <span class="fu">aes</span>(x), <span class="at">environment =</span> <span class="fu">environment</span>()) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">xlim</span>(<span class="sc">-</span><span class="dv">4</span>,<span class="dv">4</span>) <span class="sc">+</span> <span class="fu">ylim</span>(<span class="sc">-</span><span class="fl">0.1</span>,<span class="fl">0.5</span>) <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">axis.title.y =</span> <span class="fu">element_blank</span>(), <span class="at">axis.ticks =</span> <span class="fu">element_blank</span>(), <span class="at">axis.text.x =</span> <span class="fu">element_blank</span>(), <span class="at">axis.text.y =</span> <span class="fu">element_blank</span>(), <span class="at">plot.margin=</span><span class="fu">unit</span>(<span class="fu">c</span>(<span class="fl">0.5</span>,<span class="fl">0.25</span>,<span class="fl">0.5</span>,<span class="sc">-</span><span class="fl">0.25</span>), <span class="st">&quot;cm&quot;</span>))</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> p3 <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data=</span>tmpNoisy, <span class="fu">aes</span>(<span class="at">x=</span>x, <span class="at">y=</span>y), <span class="at">size=</span><span class="fl">1.5</span> )</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> p3 <span class="sc">+</span> <span class="fu">geom_line</span>( <span class="at">data=</span>tmpPred3, <span class="fu">aes</span>(<span class="at">x=</span>x, <span class="at">y=</span>y), <span class="at">linetype=</span><span class="dv">1</span>, <span class="at">color=</span><span class="st">&#39;blue&#39;</span> )</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> p3 <span class="sc">+</span> <span class="fu">xlab</span>(<span class="fu">expression</span>(<span class="fu">atop</span>(lambda<span class="sc">*</span><span class="st">&#39; = 0&#39;</span>, <span class="fu">paste</span>(<span class="st">&#39;DF = N&#39;</span>))))</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="fu">grid.arrange</span>(p0,p1,p2,p3, <span class="at">ncol=</span><span class="dv">4</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<blockquote>
<p>Multiple smoothing-spline fits of noisy realisations generated from a
true smooth underlying function of time . A true smooth underlying
function (continuous green line) is observed at multiple time points
(dots). Noise is added to these measurements and the underlying function
is approximated using smooth-splines at multiple levels of smoothness
(blue continuous line).</p>
<ul>
<li><p>Excessive smoothness makes the fit less sensitive to the data,
resulting in an under-fitted model.</p></li>
<li><p>When the curvature is not penalised an interpolating spline
passing exactly through each point is selected, resulting in an
over-fitted model.</p></li>
<li><p>At intermediate levels of smoothness, a compromise between the
goodness-of-fit and model complexity can be achieved, generating a
satisfactory approximation of the true underlying function of
time.</p></li>
</ul>
</blockquote>
<p>In practice, the results are resilient to the <em>df</em> value
selected across all variables, which is a function of the <em>study
design</em>, such as the <em>number of time-points</em>, <em>sampling
rate</em> and, most importantly, the <em>complexity of the underlying
function of time</em>. While an automated approach cannot infer the
study design from a limited set of observations, an informed user will
intuitively achieve a more consistent fit of the data.</p>
<p><code>santaR</code> considers <em>df</em> as the single
meta-parameter a user must choose prior to analysis, balancing the
fitting of raw observations versus the smoothing of the biological
variability and measurements errors. In turn, this explicit selection of
the model complexity reduces the execution time and increases the
reproducibility of results for a given experiment and across
datasets.</p>
<p>For more information regarding the selection of an optimal value of
<em>df</em> see the vignette <a href="selecting-optimal-df.html">‘Selecting an optimal number of degrees
of freedom’</a></p>
</div>
<div id="group-mean-curve-fitting" class="section level2">
<h2>Group mean curve fitting</h2>
<p>Individual time-trajectories provide with subject-specific
approximations of the underlying function of time. If a homogenous
subset of the population (or group) can be devised, the replication of
the experiment over this group can be leveraged to generate a group mean
curve. This group mean curve provide with an approximation of the
underlying function of time potentially dissociated of inter-individual
variability.</p>
<p>A group mean curve <span class="math inline">\(g(t)\)</span>,
representing the underlying function of time for a subset of the
population, is defined as the mean response across all <span class="math inline">\(i\)</span> group subjects (where <span class="math inline">\(i=1,.,n_k\)</span>) (Equation 3): <span class="math display">\[g(t)=\frac{1}{n_k} \sum_{i=1}^{n_k} f_i(t) =
\overline{f_i(t)}\]</span> (Eq. 3)</p>
<p>Following the framework of FDA, each individual trajectory is
employed as the new basic unit of information. The group mean curve
therefore employs the back-projection of each individual curve at every
time of interest, instead of relying on each discrete measurement. This
way the group mean curve fit is resilient to missing samples in a
subject trajectory or asynchronous measurement across individuals.</p>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<blockquote>
<p>Multiple group mean curve fits (Center and Right) based on
measurements generated from a true smooth underlying function of time
(Left) with added inter-individual variability and missing observations.
Multiple individual trajectories (Left, dashed green lines) are
generated from a true underlying function of time (Left, continuous
green line). Discrete measurements are generated (dots). Group mean
curves are computed on a subset of these measurements (Center and Right,
continuous blue line, 5 effective degrees of freedom). When the group
mean curve is generated solely based on measurements (Center), the true
underlying function of time is not satisfactorily approximated
(fundamental unit of information is the observation). When the group
mean curve (Right, continuous blue line) is generated from each
individual curves (Right, dashed blue lines) a satisfactory
approximation of the true underlying function of time can be obtained
(fundamental unit of information is the functional representation of
each individual).</p>
</blockquote>
</div>
<div id="intra-class-variability-confidence-bands-on-the-group-mean-curves" class="section level2">
<h2>Intra-class variability (confidence bands on the group mean
curves)</h2>
<p>Confidence bands are employed to represent the uncertainty in an
function’s estimate based on limited or noisy data. Pointwise confidence
bands on the group mean curve can therefore provide a visualisation of
the variance of the overall mean function through time. The confidence
bands indicate for each possible time, values of the mean curve which
could have been produced by the provided individual trajectories, with
at least a given probability.</p>
<p>As the underlying distribution of <span class="math inline">\(F(t)\)</span> is unknown and inaccessible,
confidence on <span class="math inline">\(g(t)\)</span> must be
estimated by sampling the approximate distribution available (i.e. the
measurements), achieved by bootstrapping the observations<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> <a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a> <a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>. Bootstrap assumes
that sampling the distribution under a good estimate of the truth (the
measurements) should be close to sampling the distribution under the
true process. Once a bootstrapped distribution of mean curve is
estimated, using the percentile method a pointwise confidence interval
on <span class="math inline">\(g(t)\)</span> can be calculated<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a> <a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a> <a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a> by
taking the <span class="math inline">\(\alpha/2\)</span> and <span class="math inline">\(1-\alpha/2\)</span> quantiles at each time-point
of interest (where <span class="math inline">\(\alpha\)</span> is the
error quantile in percent).</p>
<p>As limited assumptions on the fitted model can be established,
empirical confidence bands on the group mean curve are calculated based
on a non-parametric bootstrapped distribution. Individual curves are
sampled with replacement and group mean curves calculated. The
distribution of group mean curve is then employed to estimate the
pointwise confidence bands.</p>
</div>
<div id="detection-of-significantly-altered-time-trajectories" class="section level2">
<h2>Detection of significantly altered time-trajectories</h2>
<p>With a continuous time representation of a metabolite’s concentration
accessible (i.e. the group mean curve), a metric quantifying a global
difference between such curves can be devised. This measure of
difference, independent of the original sampling of the data
(e.g. asynchronous and missing measurements), can then be employed to
determine whether the group mean curves are identical across the two
groups and calculate the significance of the result.</p>
<p>In order to identify time-trajectories that are significantly altered
between two experimental groups <span class="math inline">\(G_1\)</span>
and <span class="math inline">\(G_2\)</span>, this global measure must
be established. The measure must be able to detect baseline difference
when both curves present the same shape, but also shape differences when
the mean values across time are identical for both groups. We postulate
that the area between two group mean curves fitted independently <span class="math inline">\(g_1(t)\)</span> and <span class="math inline">\(g_2(t)\)</span> (Eq. 3) is a good measure of the
degree to which the two group time-trajectories differ. This global
distance measure is calculated as:</p>
<p><span class="math display">\[dist(g_1,g_2) = \int_{t_{min}}^{t_{max}}
|g_1(t)-g_2(t)| ~dt\]</span> (Eq. 4)</p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(t_{min}\)</span> and <span class="math inline">\(t_{max}\)</span> are the lower and upper bound of
the time course.</li>
</ul>
<p>The global distance measure is a quantification of evidence for
differential time evolution, and the larger the value, the more the
trajectories differ.</p>
<p>Given the groups <span class="math inline">\(G_1\)</span>, <span class="math inline">\(G_2\)</span>, their respective group mean curves
<span class="math inline">\(g_1(t)\)</span>, <span class="math inline">\(g_2(t)\)</span> and the observed global distance
measure <span class="math inline">\(dist(g_1,g_2)\)</span>, the question
of the significance of the difference between the two time trajectories
is formulated as the following hypothesis-testing problem:</p>
<ul>
<li><span class="math inline">\(H_0\)</span>: <span class="math inline">\(g_1(t)\)</span> and <span class="math inline">\(g_2(t)\)</span> are identical.</li>
<li><span class="math inline">\(H_1\)</span>: The two curves are not the
same.</li>
</ul>
<p>Under the null hypothesis <span class="math inline">\(H_0\)</span>,
the global distance between <span class="math inline">\(g_1(t)\)</span>
and <span class="math inline">\(g_2(t)\)</span> can be generated by a
randomly permuting the individuals between two groups. Under the
alternate hypothesis <span class="math inline">\(H_1\)</span>, the two
curves are different, and very few random assignment of individuals to
groups will generate group mean curves that differ more than the
observed ones (i.e. a larger global distance).</p>
<p>In order to test the null hypothesis, the observed global distance
must be compared to the expected global distance under the null
hypothesis. The null distribution of the global distance measure is
inferred by repeated permutations of the individual class labels<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>.
Individual trajectories are fit using the chosen <em>df</em> and
randomly assigned in one of two groups of size <span class="math inline">\(s_1\)</span> and <span class="math inline">\(s_2\)</span> (identical to the size of <span class="math inline">\(G_1\)</span> and <span class="math inline">\(G_2\)</span> respectively). The corresponding
group mean curves <span class="math inline">\(g&#39;_1(t)\)</span> and
<span class="math inline">\(g&#39;_2(t)\)</span> computed, and a global
distance <span class="math inline">\(dist(g&#39;_1,g&#39;_2)\)</span>
calculated. This is repeated many times to form the null distribution of
the global distance. From this distribution a <span class="math inline">\(p\)</span>-value can be computed as the proportion
of global distance as extreme or more extreme than the observed global
distance (<span class="math inline">\(dist(g_1,g_2)\)</span>). The <span class="math inline">\(p\)</span>-value indicates the probability (if the
null hypothesis was true) of a global difference as, or more, extreme
than the observed one. If the <span class="math inline">\(p\)</span>-value is inferior to an agreed
significance level, the null hypothesis is rejected.</p>
<p>Due to the stochastic nature of the permutations, the null
distribution sampled depends on the random draw, resulting in possible
variation of the <span class="math inline">\(p\)</span>-value. Variation
on the permuted <span class="math inline">\(p\)</span>-value can be
described by confidence intervals. The <span class="math inline">\(p\)</span>-value is considered as the success
probability parameter <span class="math inline">\(p\)</span> in <span class="math inline">\(n\)</span> independent Bernoulli trials, where
<span class="math inline">\(n=B\)</span> the total number of permutation
rounds<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>. Confidence intervals on this binomial
distribution of parameter <span class="math inline">\(p\)</span> and
<span class="math inline">\(n\)</span> can then be computed. As extreme
<span class="math inline">\(p\)</span>-values are possible (i.e close to
0) and the number of permutation rounds could be small, the Wilson score
interval<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a> is employed to determine the confidence
intervals (Eq. 5):</p>
<p><span class="math display">\[p_\pm = \frac{1}{1+\frac{1}{B}z^2}\left
( p + \frac{1}{2B}z^2 \pm z\sqrt{\frac{1}{B} p (1 - p) +
\frac{1}{4B^2}z^2 }  \right )\]</span> (Eq. 5)</p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(p_\pm\)</span> is the upper or lower
confidence interval.</li>
<li><span class="math inline">\(p\)</span> is the calculated <span class="math inline">\(p\)</span>-value.</li>
<li><span class="math inline">\(B\)</span> the total number of
permutation rounds.</li>
<li><span class="math inline">\(z\)</span> is the <span class="math inline">\(1-1/2\alpha\)</span> quantile of the standard
normal distribution, with <span class="math inline">\(\alpha\)</span>
the error quantile.</li>
</ul>
<p>Lastly, if a large number of variables are investigated for
significantly altered trajectories, significance results must be
corrected for multiple hypothesis testing. Here we employ the well-known
Benjamini &amp; Hochberg false discovery rate approach<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a> as default, with
other methods available as an option.</p>
</div>
<div id="see-also" class="section level2">
<h2>See Also</h2>
<ul>
<li><a href="getting-started.html">Getting Started with santaR</a></li>
<li><a href="prepare-input-data.html">How to prepare input data for
santaR</a></li>
<li><a href="santaR-GUI.pdf">Graphical user interface use</a></li>
<li><a href="automated-command-line.html">Automated command line
analysis</a></li>
<li><a href="plotting-options.html">Plotting options</a></li>
<li><a href="selecting-optimal-df.html">Selecting an optimal number of
degrees of freedom</a></li>
<li><a href="advanced-command-line-functions.html">Advanced command line
options</a></li>
</ul>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>Ramsay, J. &amp; Silverman, B. W. <em>Functional Data
Analysis</em> Springer, 431 (John Wiley &amp; Sons, Ltd, Chichester, UK,
2005)<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Ramsay, J., Hooker, G. &amp; Graves, S. <em>Functional
data analysis with R and MATLAB</em> (Springer-Verlag, 2009)<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>Ramsay, J. O. &amp; Silverman, B. <em>Applied functional
data analysis: methods and case studies</em> (eds Ramsay, J. O. &amp;
Silverman, B. W.) (Springer New York, New York, NY, 2002)<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>Ramsay, J. &amp; Silverman, B. W. <em>Functional Data
Analysis</em> Springer, 431 (John Wiley &amp; Sons, Ltd, Chichester, UK,
2005)<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Ramsay, J. &amp; Silverman, B. W. <em>Functional Data
Analysis</em> Springer, 431 (John Wiley &amp; Sons, Ltd, Chichester, UK,
2005)<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>Ramsay, J., Hooker, G. &amp; Graves, S. <em>Functional
data analysis with R and MATLAB</em> (Springer-Verlag, 2009)<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>Anselone, P. M. &amp; Laurent, P. J. A general method
for the construction of interpolating or smoothing spline-functions.
<em>Numer. Math</em>. 12, 66-82 (1968)<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>Green, P. &amp; Silverman, B. W. <em>Nonparametric
regression and generalized linear models: a roughness penalty
approach</em>. (Chapman &amp; Hall/CRC, 1994)<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p>de Boor, C. <em>A Practical Guide to Splines</em>.
(Springer-Verlag, 1978)<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p>Hastie, T., Tibshirani, R. &amp; Friedman, J. <em>The
Elements of Statistical Learning</em>. (Springer, 2009)<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
<li id="fn11"><p>Eubank, R. . The hat matrix for smoothing splines.
<em>Stat. Probab. Lett</em>. 2, 9-14 (1984)<a href="#fnref11" class="footnote-back">↩︎</a></p></li>
<li id="fn12"><p>Buja, A., Hastie, T. &amp; Tibshirani, R. Linear
Smoothers and Additive Models. <em>Ann. Stat</em>. 17, 453-510 (1989)<a href="#fnref12" class="footnote-back">↩︎</a></p></li>
<li id="fn13"><p>Efron, B. Bootstrap Methods: Another Look at the
Jackknife. <em>Ann. Stat</em>. 7, 1-26 (1979)<a href="#fnref13" class="footnote-back">↩︎</a></p></li>
<li id="fn14"><p>Davison, A. &amp; Hinkley, D. <em>Bootstrap methods and
their application</em>. (Cambridge University Press, 1997)<a href="#fnref14" class="footnote-back">↩︎</a></p></li>
<li id="fn15"><p>Davison, A. C., Hinkley, D. V. &amp; Young, G. A.
Recent Developments in Bootstrap Methodology. <em>Stat. Sci</em>. 18,
141-157 (2003)<a href="#fnref15" class="footnote-back">↩︎</a></p></li>
<li id="fn16"><p>Claeskens, G. &amp; Van Keilegom, I. Bootstrap
confidence bands for regression curves and their derivatives. <em>Ann.
Stat</em>. 31, 1852-1884 (2003)<a href="#fnref16" class="footnote-back">↩︎</a></p></li>
<li id="fn17"><p>DiCiccio, T. J. &amp; Efron, B. Bootstrap confidence
intervals. <em>Stat. Sci</em>. 11, 189-228 (1996)<a href="#fnref17" class="footnote-back">↩︎</a></p></li>
<li id="fn18"><p>Efron, B. Better bootstrap confidence intervals. <em>J.
Am. Stat. Assoc</em>. 82, 171-185 (1987)<a href="#fnref18" class="footnote-back">↩︎</a></p></li>
<li id="fn19"><p>Ernst, M. D. Permutation Methods: A Basis for Exact
Inference. <em>Stat. Sci</em>. 19, 676-685 (2004)<a href="#fnref19" class="footnote-back">↩︎</a></p></li>
<li id="fn20"><p>Li, J., Tai, B. C. &amp; Nott, D. J. Confidence
interval for the bootstrap P-value and sample size calculation of the
bootstrap test. <em>J. Nonparametr. Stat</em>. 21, 649-661 (2009)<a href="#fnref20" class="footnote-back">↩︎</a></p></li>
<li id="fn21"><p>Wilson, E. B. Probable Inference, the Law of
Succession, and Statistical Inference. <em>J. Am. Stat. Assoc</em>. 22,
209 (1927)<a href="#fnref21" class="footnote-back">↩︎</a></p></li>
<li id="fn22"><p>Benjamini, Y. &amp; Hochberg, Y. Controlling the False
Discovery Rate: A Practical and Powerful Approach to Multiple Testing.
<em>J. R. Stat. Soc. Ser. B</em> 57, 289 - 300 (1995)<a href="#fnref22" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
